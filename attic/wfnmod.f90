
  subroutine evalwfn(m,mesh)
    use param
    !     
    !     HARTMUT SCHMIDER March 2005
    !     Produces various properties on a Gaussian type cube grid
    !
    !     Adapted by Erin R. Johnson and Axel D. Becke, March 2005
    !     Uses grid generated by numol and returns
    !     properties and wavefunctions at all grid points
    !
    type(molecule), intent(inout) :: m
    type(tmesh), intent(inout) :: mesh

    integer :: i, istat, nmo1, nmo2
    integer :: inuc
    real*8 :: quads, dsigs, hirsh(mesh%n), r, r1, r2

    istat = 0
    if (.not.allocated(mesh%rho)) allocate(mesh%rho(mesh%n,2),stat=istat)
    if (istat /= 0) call error('evalwfn','could not allocate memory for rho',2)
    if (.not.allocated(mesh%b)) allocate(mesh%b(mesh%n,2),stat=istat)
    if (istat /= 0) call error('evalwfn','could not allocate memory for tau',2)
    
    call propts(m,mesh%n,mesh%x,mesh%rho,mesh%b)

    if (.not.allocated(m%mm)) allocate(m%mm(3,m%n),stat=istat)
    if (istat /= 0) call error('evalwfn','could not allocate memory for moments',2)
    if (.not.allocated(m%v)) allocate(m%v(m%n),stat=istat)
    if (istat /= 0) call error('evalwfn','could not allocate memory for volumes',2)
    if (.not.allocated(m%q)) allocate(m%q(m%n),stat=istat)
    if (istat /= 0) call error('evalwfn','could not allocate memory for charges',2)
    m%mm = 0d0
    m%v = 0d0
    m%q = 0d0

    rewind(ihrsh)
    do inuc = 1, m%n
       if (m%z(inuc) < 1) cycle
       read(ihrsh)(hirsh(i),i=1,mesh%n)
       m%mm(:,inuc) = 0d0
       m%v(inuc) = 0d0
       m%q(inuc) = 0d0

       ! calculate hole dipole and moments
       do i = 1, mesh%n
          r = sqrt(dot_product(mesh%x(:,i)-m%x(:,inuc),mesh%x(:,i)-m%x(:,inuc)))
          r1 = max(0.d0,r-mesh%b(i,1))
          r2 = max(0.d0,r-mesh%b(i,2))

          m%mm(1,inuc)=m%mm(1,inuc) + mesh%w(i) * hirsh(i) * &
             (mesh%rho(i,1) * (r-r1)**2 + mesh%rho(i,2) * (r-r2)**2)
          m%mm(2,inuc)=m%mm(2,inuc) + mesh%w(i) * hirsh(i) * &
             (mesh%rho(i,1) * (r**2-r1**2)**2 + mesh%rho(i,2) * (r**2-r2**2)**2)
          m%mm(3,inuc)=m%mm(3,inuc) + mesh%w(i) * hirsh(i) * &
             (mesh%rho(i,1) * (r**3-r1**3)**2 + mesh%rho(i,2) * (r**3-r2**3)**2)
          m%v(inuc) = m%v(inuc) + mesh%w(i) * hirsh(i) * &
             (mesh%rho(i,1)+mesh%rho(i,2)) * r**3
          m%q(inuc) = m%q(inuc) + mesh%w(i) * hirsh(i) * (mesh%rho(i,1)+mesh%rho(i,2))
       enddo
    enddo

  end subroutine evalwfn

 subroutine propts(m,nr,r,rho,b)
   
         prho(2) = prho(1)
         if (prho(1) > small) then
            drho2 = gg(1)*gg(1)+gg(2)*gg(2)+gg(3)*gg(3)
            d2rho = hh(1)+hh(2)+hh(3)
            dsigs = taup - 0.25d0 * drho2 / max(prho(1),1d-30)
            quads = (d2rho - 2d0 * dsigs) / 6d0
            call bhole(prho(1),quads,1d0,pb(1))
            pb(2) = pb(1)
         endif

 subroutine bhole(rho,quad,hnorm,b)
   use param

   real*8, intent(in) :: rho, quad, hnorm
   real*8, intent(out) :: b 

   real*8 :: rhs, x0, shift, x, x1, expo, prefac, alf, f, df
   integer :: i

   rhs=third2*(pi*rho/hnorm)**third2*rho/quad
   x0=2.d0
   shift=1.d0
   if(rhs.lt.0.d0)go to 10
   if(rhs.gt.0.d0)go to 20
10 do i=1,16
      x=x0-shift
      call xfuncs(x,rhs,f,df)
      if(f.lt.0.d0)go to 88
      shift=0.1d0*shift
   enddo
   write(iout,1002)
   stop
20 do i=1,16
      x=x0+shift
      call xfuncs(x,rhs,f,df)
      if(f.gt.0.d0)go to 88
      shift=0.1d0*shift
   enddo
   write(iout,1002)
   stop
88 continue
   do i=1,100
      call xfuncs(x,rhs,f,df)
      x1=x-f/df
      if(dabs(x1-x).lt.1.d-10)go to 111
      x=x1
   enddo
   write(iout,1001)
   stop
111 x=x1
   expo=dexp(-x)
   prefac=rho/expo
   alf=(8.d0*pi*prefac/hnorm)**third
   b=x/alf
   return
1001 format(' ','bhole: newton algorithm fails to converge!')
1002 format(' ','bhole: newton algorithm fails to initialize!')
 end subroutine bhole


 subroutine xfuncs(x,rhs,f,df)
   real*8, intent(in) :: x, rhs
   real*8, intent(out) :: f, df

   real*8 :: expo23

   expo23=dexp(-2.d0/3.d0*x)
   f = x*expo23/(x-2.d0) - rhs
   df=2.d0/3.d0*(2.d0*x-x**2-3.d0)/(x-2.d0)**2*expo23
 end subroutine xfuncs

 subroutine edisp(m,a1,a2,egauss,usec9)
   type(molecule), intent(in) :: m
   real*8, intent(in) :: a1, a2, egauss
   logical, intent(in) :: usec9

   integer :: i, j, k, k1, k2
   real*8 :: d, atpol(m%n), fac, rvdw, c6, c8, c10, rc
   real*8 :: c6com, c8com, c10com, xij(3), ifac
   real*8 :: e, f(3,m%n), q(3,m%n,3,m%n), qfac
   real*8 :: c9, qi, qj, qk

   do i = 1, m%n
      if (m%z(i) < 1) cycle
      atpol(i) = m%v(i) * frepol(m%z(i)) / frevol(m%z(i))
      ! write (iout,'("MOMENT",X,1p,2(E18.10,X))') m%mm(1,i), atpol(i)
   enddo

   write (iout,'("coefficients and distances (a.u.)")')
   write (iout,'("# i  j       dij            C6               C8               C10              Rc           Rvdw")') 
   e = 0d0
   f = 0d0
   q = 0d0
   do i = 1, m%n
      if (m%z(i) < 1) cycle
      do j = i, m%n
         if (m%z(j) < 1) cycle
         xij = m%x(:,j)-m%x(:,i)
         d = sqrt(dot_product(xij,xij))
         fac = atpol(i)*atpol(j)/(m%mm(1,i)*atpol(j)+m%mm(1,j)*atpol(i))
         c6 = fac*m%mm(1,i)*m%mm(1,j)
         c8 = 1.5d0*fac*(m%mm(1,i)*m%mm(2,j)+m%mm(2,i)*m%mm(1,j))
         c10 = 2.d0*fac*(m%mm(1,i)*m%mm(3,j)+m%mm(3,i)*m%mm(1,j))&
            +4.2d0*fac*m%mm(2,i)*m%mm(2,j)
         rc = (sqrt(c8/c6) + sqrt(sqrt(c10/c6)) +&
            sqrt(c10/c8)) / 3.D0
         rvdw = a1 * rc + a2
         if (d > 1d-5) then
            e = e - c6 / (rvdw**6 + d**6) - c8 / (rvdw**8+d**8) - &
               c10 / (rvdw**10 + d**10)
            c6com = 6.d0*c6*d**4/(rvdw**6+d**6)**2
            c8com = 8.d0*c8*d**6/(rvdw**8+d**8)**2
            c10com = 10.d0*c10*d**8/(rvdw**10+d**10)**2
            f(:,i) = f(:,i) + (c6com+c8com+c10com) * xij
            f(:,j) = f(:,j) - (c6com+c8com+c10com) * xij
            do k1 = 1, 3
               do k2 = 1, 3
                  if (k1 == k2) then
                     ifac = 1d0
                  else
                     ifac = 0d0
                  endif
                  qfac = &
                     c6com  * (-ifac - 4*xij(k1)*xij(k2)/d**2 + 12*xij(k1)*xij(k2)*d**4/(rvdw**6+d**6)) + &
                     c8com  * (-ifac - 6*xij(k1)*xij(k2)/d**2 + 16*xij(k1)*xij(k2)*d**6/(rvdw**8+d**8)) + &
                     c10com * (-ifac - 8*xij(k1)*xij(k2)/d**2 + 20*xij(k1)*xij(k2)*d**8/(rvdw**10+d**10)) 
                  q(k1,i,k2,j) = qfac
                  q(k2,j,k1,i) = qfac
               enddo
            enddo
         endif
         write (iout,'(I3,X,I3,1p,E14.6,X,3(E16.9,X),2(E13.6,X))') &
            i, j, d, c6, c8, c10, rc, rvdw
      end do
   end do
   write (iout,'("#")')

   if (usec9) then
      write (iout,'("three-body dispersion coefficients (a.u.)")')
      write (iout,'("# i  j  k            C9")')
      do i = 1, m%n
         if (m%z(i) < 1) cycle
         do j = i, m%n
            if (m%z(j) < 1) cycle
            do k = j, m%n
               if (m%z(k) < 1) cycle

               qi = m%mm(1,i) / atpol(i)
               qj = m%mm(1,j) / atpol(j)
               qk = m%mm(1,k) / atpol(k)

               c9 = m%mm(1,i)*m%mm(1,j)*m%mm(1,k)* (qi+qj+qk) / ((qi+qj)*(qi+qk)*(qj+qk))
               write (iout,'(3(I3,X)1p,E16.9)') i, j, k, c9

            end do
         end do
      end do
      write (iout,'("#")')
   end if

   ! sum rules for the second derivatives
   do i = 1, m%n
      do k1 = 1, 3
         do k2 = 1, 3
            q(k1,i,k2,i) = 0d0
            do j = 1, m%n
               if (j == i) cycle
               q(k1,i,k2,i) = q(k1,i,k2,i) - q(k1,i,k2,j)
            enddo
         enddo
      enddo
   enddo

   write (iout,'("dispersion energy ",1p,E20.12)') e
   write (iout,'("scf energy ",1p,E20.12)') egauss
   write (iout,'("total energy (SCF+XDM) ",1p,E20.12)') egauss+e
   write (iout,'("dispersion forces ")')
   write (iout,'("# i          Fx                   Fy                   Fz")')
   do i = 1, m%n
      write (iout,'(I3,X,1p,3(E20.12,X))') i, f(:,i)
   enddo
   write (iout,'("#")')
   write (iout,'("dispersion force constant matrix ")')
   write (iout,'("# i  xyz   j   xyz    Exixj ")')
   do i = 1, m%n
      do k1 = 1, 3
         do j = 1, i-1
            do k2 = 1, 3
               write (iout,'(4(I3,X),1p,E20.12)') i, k1, j, k2, q(k1,i,k2,j)
            enddo
         enddo
         do k2 = 1, k1
            write (iout,'(4(I3,X),1p,E20.12)') i, k1, i, k2, q(k1,i,k2,i)
         enddo
      enddo
   enddo
   write (iout,'("#"/)')
   
 end subroutine edisp

 function read_integers(lu,n) result(x)
   integer, intent(in) :: lu, n
   integer :: x(n)

   integer :: kk, lp, idum
   character*(mline) :: line

   kk = 0
   lp = 1
   read(lu,'(A)',end=999) line
   do while(.true.)
      if (.not.isinteger(idum,line,lp)) then
         lp = 1
         read(lu,'(A)',end=999) line
         line = adjustl(line)
         if (line(1:2) == "</") exit
      else
         kk = kk + 1
         if (kk > n) call error("read_integers","exceeded size of the array",2)
         x(kk) = idum
      endif
   enddo
   
   return
999 call error("read_integers","unexpected end of file",2)

 endfunction read_integers

 function read_reals1(lu,n) result(x)
   integer, intent(in) :: lu, n
   real*8 :: x(n)

   integer :: kk, lp
   real*8 :: rdum
   character*(mline) :: line

   kk = 0
   lp = 1
   read(lu,'(A)',end=999) line
   do while(.true.)
      if (.not.isreal(rdum,line,lp)) then
         lp = 1
         read(lu,'(A)',end=999) line
         line = adjustl(line)
         if (line(1:1) == "<") exit
      else
         kk = kk + 1
         if (kk > n) call error("read_reals1","exceeded size of the array",2)
         x(kk) = rdum
      endif
   enddo
   
   return
999 call error("read_reals1","unexpected end of file",2)

 endfunction read_reals1

end module wfnmod
