
    call allocate_space_for_surface (npang,minter)
    call cpu_time (time1)
    !$ time1 = omp_get_wtime()
    !$omp parallel default(none) &
    !$omp private(j,nsurf,rsurf) &
    !$omp shared(npang,ct,st,cp,sp,epsilon,rlimsurf,nlimsurf)
    !$omp do schedule(dynamic)
    do j = 1,npang
      write (*,*) ct(j),st(j),cp(j),sp(j)
      call ray (ct(j),st(j),cp(j),sp(j),rsurf,nsurf)
      do k = 1,nsurf
        rlimsurf(j,k) = rsurf(k,2)
      end do
      nlimsurf(j) = nsurf
    end do
    !$omp end do nowait
    !$omp end parallel
    call cpu_time (time2)
    !$ time2 = omp_get_wtime()
    if (verbose) then
      write (uout,'(1x,a,1x,f12.5)') string('# Surface Elapsed seconds :'), time2-time1
    end if

    rmins = 1000_rp
    rmaxs = 0.0_rp
    open (lsu,file=trim(filesurf)//d4,form='unformatted')
    if (verbose) open (ltxt,file=trim(filesurf)//"-txt"//d4)
    write (lsu) npang, inuc
    write (lsu) (nlimsurf(j),j=1,npang)
    if (verbose) then
      write (ltxt,111) npang, inuc
      write (ltxt,333) (nlimsurf(j),j=1,npang)
      write (ltxt,109)
    end if
    do j = 1,npang
      nsurf = nlimsurf(j)
      rmins = min(rmins,rlimsurf(j,1))
      rmaxs = max(rmaxs,rlimsurf(j,nsurf))
      if (verbose) then
        write (ltxt,222) ct(j),st(j),cp(j),sp(j),angw(j),(rlimsurf(j,k),k=1,nsurf)
      end if
      write (lsu) ct(j),st(j),cp(j),sp(j),angw(j),(rlimsurf(j,k),k=1,nsurf)
    end do
    if (verbose) then
      write (ltxt,222) rmins,rmaxs
      close (ltxt)
    end if
    write (lsu) rmins,rmaxs
    close (lsu)
  subroutine ray (cot,sit,cop,sip,rsurf,nsurf)

    use mod_io, only: ferror, faterr
    use mod_wfn, only: ncent
    use mod_odeint, only: odeint
    use mod_fields, only: pointr1
    implicit none
 
    integer(kind=ip), intent(out) :: nsurf
    real(kind=rp), intent(in) :: cot, sit, cop, sip
    real(kind=rp), intent(out) :: rsurf(minter,2) 
 
    logical :: inf, good
    integer(kind=ip) :: nintersec, nt
    integer(kind=ip) :: isurf(minter,2), i, ia, ib, im, ncount
    real(kind=rp) :: sintcosp, sintsinp
    real(kind=rp) :: xin(3), xfin(3), xpoint(3), xmed(3), ra, ract
    real(kind=rp) :: xdeltain(3), xsurf(0:minter,3), rb, rm, cost
 
    cost = cot
    sintcosp = sit*cop
    sintsinp = sit*sip
 
    if (ncent.eq.1) then
      nsurf = 1
      rsurf(1,1) = 0.0_rp
      rsurf(1,2) = rmaxsurf
      return
    end if
 
    inf = .false.
    ncount = 0_ip
    nintersec = 0_ip
    ia = inuc
    ra = 0.0_rp
    geofac = ((rmaxsurf-0.1_rp)/rprimer)**(1.0_rp/(ntrial-1))

    do i = 1,ntrial
      ract = rprimer*geofac**(i-1)
      xdeltain(1) = ract*sintcosp
      xdeltain(2) = ract*sintsinp
      xdeltain(3) = ract*cost    
      xpoint(:) = xnuc(:) + xdeltain(:)
      !call odeint (xpoint,0.1_rp,1.0_rp,inf,epsilon,xnuc,steeper,pointr1,iscp)
      call odeint (xpoint,0.1_rp,epsilon,xnuc,pointr1,iscp)
      good = iscp(xpoint,ib)
      rb = ract
      if (ib.ne.ia .and. (ia.eq.inuc .or. ib.eq.inuc)) then
        if (ia.ne.inuc .or. ib.ne.-1) then
          nintersec = nintersec + 1_ip
          if (nintersec.gt.minter) then
            call ferror('surf', 'increase minter in mod_surf', faterr)
          end if
          xsurf(nintersec,1) = ra
          xsurf(nintersec,2) = rb
          isurf(nintersec,1) = ia
          isurf(nintersec,2) = ib
        end if
      end if
      ia = ib
      ra = rb
    end do        ! looking for intersections

    ! We have now a consistent set of trial points. 
    ! Let us refine by bipartition, consistency check added. 
    ! No other nuclei basins can be found other than those explicit in isurf
    do i = 1,nintersec
      ia = isurf(i,1)
      ib = isurf(i,2)
      ra = xsurf(i,1)
      rb = xsurf(i,2)
      xin(1) = xnuc(1) + ra*sintcosp
      xin(2) = xnuc(2) + ra*sintsinp
      xin(3) = xnuc(3) + ra*cost
      xfin(1) = xnuc(1) + rb*sintcosp
      xfin(2) = xnuc(2) + rb*sintsinp
      xfin(3) = xnuc(3) + rb*cost
      do while (abs(ra-rb).gt.epsilon)
        ! Mean Value 
        xmed(:) = 0.5_rp*(xfin(:)+xin(:))    
        rm = (ra+rb)*0.5_rp
        xpoint(:) = xmed(:)
        !call odeint (xpoint,0.1_rp,1.0_rp,inf,epsilon,xnuc,steeper,pointr1,iscp)
        call odeint (xpoint,0.1_rp,epsilon,xnuc,pointr1,iscp)
        good = iscp(xpoint,im)
        ! bipartition
        if (im.eq.ia) then
          xin(:) = xmed(:)
          ra = rm
        else if (im.eq.ib) then
          xfin(:) = xmed(:)
          rb = rm
        else
          if (ia.eq.inuc) then
            xfin(:) = xmed(:)
            rb = rm
          else
            xin(:) = xmed(:)
            ra = rm
          end if
        end if
      end do
      ! found. Mean value
      xpoint(:) = 0.5_rp*(xfin(:)+xin(:))    
      xsurf(i,3) = (ra+rb)*0.5_rp
    end do

    ! organize pairs
    nsurf = 0_ip
    xsurf(0,3) = 0.0_rp
    ia = inuc
    nsurf = nintersec
    do i = 1,nsurf
      rsurf(i,2) = xsurf(i,3)
    end do
    nt = mod(nintersec,2)
    if (nt.eq.0) then
      nsurf = nsurf + 1_ip
      rsurf(nsurf,2) = rmaxsurf
    end if
    write (*,*) "# *********** ", nsurf
    do i = 1,nsurf
      write (*,*) "# *********** ", rsurf(i,2)
    end do
 
  end subroutine


----> ODEINT  

  public :: odeint

contains

  subroutine odeint (y,h,eps,xnuc,field,check)
 
    use mod_param, only: vsmall
    use mod_io, only: faterr, ferror, string
    implicit none

    ! Arguments
    real(kind=rp), intent(inout) :: y(3)
    real(kind=rp), intent(in) :: h
    real(kind=rp), intent(in) :: eps
    real(kind=rp), intent(in) :: xnuc(3)
    
    ! Local vars
    integer(kind=ip) :: nstp, nuc
    real(kind=rp) :: dydx(3), h1
    real(kind=rp) :: a1, a2, a3
    real(kind=rp) :: rho, grad(3), gradmod

    interface
      subroutine field (p,rho,grad,gradmod)
        import rp
        real(kind=rp), intent(in) :: p(3)
        real(kind=rp), intent(out) :: grad(3)
        real(kind=rp), intent(out) :: rho
        real(kind=rp), intent(out) :: gradmod
      end subroutine
      logical function  check (p,nuc)
        import :: rp, ip
        integer(kind=ip), intent(out) :: nuc
        real(kind=rp), intent(in) :: p(3)
      end function  
    end interface
  
    h1 = h

    call field (y,rho,grad,gradmod)
    dydx(:) = grad(:)/(gradmod+vsmall)
    if (gradmod.lt.EPSGRAD .and. rho.lt.EPSRHO) then
      return
    end if
 
    do nstp = 1,maxstp
      call rkqs (y,dydx,h1,eps,field)
      call field (y,rho,grad,gradmod)
      dydx(:) = grad(:)/(gradmod+vsmall)
      if (check(y,nuc)) then
        return
      end if
      !if (nstp.eq.maxstp) then
      !  call ferror ('mod_odeint/odeint', 'reached maxstp', faterr)
      !end if 
    end do

    ! Test if the point is far from RMAXSURF from current atom. 
    a1 = y(1) - xnuc(1)
    a2 = y(2) - xnuc(2)
    a3 = y(3) - xnuc(3)
    if ((a1*a1+a2*a2+a3*a3).ge.5d0*5d0) then
      return
    else
      call ferror ('mod_odeint/odeint', 'Non nuclear maximum at : ' &
                                         //string(y(1),'e')//' '    &  
                                         //string(y(2),'e')//' '    &  
                                         //string(y(3),'e'), faterr) 
    end if

  end subroutine

  subroutine rkqs (y,dydx,h,eps,field)
      
    use mod_param, only: vsmall
    use mod_io, only: faterr, ferror
    implicit none

    ! Parameters
    real(kind=rp), parameter :: MINSTEP = 1e-5
    real(kind=rp), parameter :: MAXSTEP = 0.75
    real(kind=rp), parameter :: SAFETY = 0.9
    real(kind=rp), parameter :: ENLARGE = 1.2
    
    ! Arguments
    real(kind=rp), dimension(3), intent(in) :: dydx
    real(kind=rp), dimension(3), intent(inout) :: y
    real(kind=rp), intent(in) :: eps
    real(kind=rp), intent(in) :: h

    ! Local vars
    real(kind=rp), dimension(3) :: yerr, ytemp
    real(kind=rp) :: err, rho, grad(3), gradmod, htemp, h1


    interface
      subroutine field (p,rho,grad,gradmod)
        import rp
        real(kind=rp), intent(in) :: p(3)
        real(kind=rp), intent(out) :: grad(3)
        real(kind=rp), intent(out) :: rho
        real(kind=rp), intent(out) :: gradmod
      end subroutine
    end interface

    grad = dydx
    h1 = h
      
    do
      call rkck (y,grad,h1,ytemp,yerr,field)
      err = norm2(yerr)
      y = ytemp
      call field (y,rho,grad,gradmod)
      grad(:) = grad(:)/(gradmod+vsmall)
      if (abs(err) .lt. eps) then
        !if (err < eps/10.0) h = min(MAXSTEP, ENLARGE*h)
        return 
      else
        htemp = SAFETY*(eps/err)*h1
        h1 = htemp
        if (abs(h) < MINSTEP) then
          call ferror ('mod_odeint/rkqs', 'stepsize underflow', faterr)
        end if
      end if
    end do
 
  end subroutine rkqs

  ! Runge-Kutta-Cash-Karp embedded 4(5)-order, with local extrapolation.
  ! Runge-Kutta embedded 4th order, Cash-Karp parametrization.
  ! ##### 6 stages, 5th order
  ! This scheme is due to Cash and Karp, see [1].
  !    
  !   0    | 0
  !   1/5	 | 1/5
  !   3/10 | 3/40	         9/40
  !   3/5	 | 3/10	         -9/10	      6/5
  !   1	   | -11/54	       5/2	        -70/27	    35/27
  !   7/8	 | 1631/55296    175/512      575/13824   44275/110592     253/4096     0
  !  ----------------------------------------------------------------------------------------
  !        | 37/378        0           250/621      125/594          0            512/1771
  !        | 2825/27648    0           18575/48384  13525/55296      277/14336    1/4
  ! 
  ! [1] *A variable order Runge-Kutta method for initial value problems with rapidly varying right-hand sides*, J. R. Cash,
  ! A. H. Karp, ACM Transactions on Mathematical Software, vol. 16,  pp. 201--222, 1990, doi:10.1145/79505.79507.
  subroutine rkck (y,dydx,h,yout,yerr,field)
      
    use mod_param, only: vsmall
    implicit none
  
    ! Arguments
    real(kind=rp), intent(in) :: dydx(3)
    real(kind=rp), intent(in) :: y(3)
    real(kind=rp), intent(out) :: yerr(3)
    real(kind=rp), intent(out) :: yout(3)
    real(kind=rp), intent(in) :: h
  
    ! Local vars
    real(kind=rp) :: rho, grad(3), gradmod
    real(kind=rp) :: ak2(3), ak3(3), ak4(3), ak5(3), ak6(3)
    real(kind=rp), parameter :: b21=0.2_rp,                           &
                                b31=3.0_rp/40.0_rp,                    &
                                b32=9.0_rp/40.0_rp,                    &
                                b41=0.3_rp,b42=-0.9_rp,b43=1.2_rp,      &
                                b51=-11.0_rp/54.0_rp,b52=2.5_rp,        &
                                b53=-70.0_rp/27.0_rp,b54=35._rp/27.0_rp, &
                                b61=1631.0_rp/55296.0_rp,              &
                                b62=175.0_rp/512.0_rp,                 &
                                b63=575.0_rp/13824.0_rp,               &
                                b64=44275.0_rp/110592.0_rp,            &
                                b65=253.0_rp/4096.0_rp                  
    real(kind=rp), parameter :: c1=37.0_rp/378.0_rp,c3=250.0_rp/621.0_rp,&
                                c4=125.0_rp/594.0_rp,                  &
                                c6=512.0_rp/1771.0_rp                   
    real(kind=rp), parameter :: dc1=c1-2825.0_rp/27648.0_rp,           &
                                dc3=c3-18575.0_rp/48384.0_rp,          &
                                dc4=c4-13525.0_rp/55296.0_rp,          &
                                dc5=-277.0_rp/14336.0_rp,              &
                                dc6=c6-0.25_rp                         
   
    interface
      subroutine field (p,rho,grad,gradmod)
        import rp
        real(kind=rp), intent(in) :: p(3)
        real(kind=rp), intent(out) :: grad(3)
        real(kind=rp), intent(out) :: rho
        real(kind=rp), intent(out) :: gradmod
      end subroutine
    end interface

    yout = y + b21*h*dydx
   
    call field (yout,rho,grad,gradmod)
    ak2(:) = grad(:)/(gradmod+vsmall) 
    yout = y + h*(b31*dydx+b32*ak2)

    call field (yout,rho,grad,gradmod)
    ak3(:) = grad(:)/(gradmod+vsmall)  
    yout = y + h*(b41*dydx+b42*ak2+b43*ak3)
  
    call field (yout,rho,grad,gradmod)
    ak4(:) = grad(:)/(gradmod+vsmall)   
    yout = y + h*(b51*dydx+b52*ak2+b53*ak3+b54*ak4)
  
    call field (yout,rho,grad,gradmod)
    ak5(:) = grad(:)/(gradmod+vsmall)    
    yout = y + h*(b61*dydx+b62*ak2+b63*ak3+b64*ak4+b65*ak5)

    call field (yout,rho,grad,gradmod)
    ak6(:) = grad(:)/(gradmod+vsmall)     
    yout = y + h*(c1*dydx+c3*ak3+c4*ak4+c6*ak6)
   
    yerr = h*(dc1*dydx+dc3*ak3+dc4*ak4+dc5*ak5+dc6*ak6)
 
  end subroutine

